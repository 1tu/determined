import { expect } from 'chai';
import * as sinon from 'sinon';
import { Computed, Observable, Observer } from '../src';
import { Value } from '../src/inner/Value';

afterEach(() => {
  // console.log(11);
});

describe('Graph', () => {
  it('Чтение', () => {
    const v1 = new Observable(2, { name: 'v1' });
    const v2 = new Observable(4, { name: 'v2' });
    const v3 = new Observable(10, { name: 'v2' });
    const toggler = new Observable(false, { name: 'toggler' });
    const c1 = new Computed(() => v1.get() + v2.get() + (toggler.get() ? v3.get() : 0), { name: 'с1' });
    const c2 = new Computed(() => c1.get() * 2, { name: 'с2' });
    const obs = new Observer(() => c2.get(), (v) => console.log('computed changed!', v));
    v1.set(3);
    setTimeout(() => v2.set(22), 2000);
  })

  it('Отписка от устаревших зависимостей и деактивация подграфа', () => {
    // Отписываемся, если при обновлении графа, все ЗАВИСИМЫЕ исчезли, а новых не появилось
    // когда при очередном WalkLink.lift - input.outputSet.size стал 0, 
    // надо зарегистрировать этот input на проверку, и возможно отписку подграфа друг от друга (с удалением кэша?)
  })

  it('Пропустить отписку при исчесновении ЗАВИСИМЫХ а потом появлении в рамках одного прохода', () => {
    // Не отписываемся, если при обновлении графа, сначала все ЗАВИСИМЫЕ исчезли, а потом появилась новая зависимость
    // когда при очередном WalkLink.lift - input.outputSet.size стал 0, 
    // надо зарегистрировать этот input на проверку, и возможно отписку подграфа друг от друга (с удалением кэша?)
  })

  it('Отписка от одного из нескольких Observer', () => {
    // При 2+ активных обсерверах, когда один перестаёт наблюдать, 
    // переставать наблюдать его подграф, но не отписаться от зависимоитей остальных активных обсерверов
  })

  it('Отписка от одного из нескольких Observer', () => {
    // При 2+ активных обсерверах, когда один перестаёт наблюдать, 
    // переставать наблюдать его подграф, но не отписаться от зависимоитей остальных активных обсерверов
  })
})